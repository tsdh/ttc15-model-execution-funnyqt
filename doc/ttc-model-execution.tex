\documentclass[submission]{eptcs}
\providecommand{\event}{TTC 2015}

\usepackage[T1]{fontenc}
\usepackage{varioref}
\usepackage{hyperref}

\usepackage{url}
\usepackage{paralist}
\usepackage{graphicx}
\usepackage[cache]{minted}
\newminted{clojure}{fontsize=\fontsize{8}{8},linenos,numbersep=3pt,numberblanklines=false,firstnumber=last}
\newmintinline{clojure}{fontsize=\small}
\newcommand{\code}{\clojureinline}

\title{Solving the TTC Model Execution Case with FunnyQT}
\author{Tassilo Horn
  \institute{Institute for Software Technology, University Koblenz-Landau, Germany}
  \email{horn@uni-koblenz.de}}

\def\titlerunning{Solving the TTC Model Execution Case with FunnyQT}
\def\authorrunning{T. Horn}

\begin{document}
\maketitle

\begin{abstract}
  This paper describes the FunnyQT solution to the TTC 2015 Model Execution
  transformation case.  The solution solves the third variant of the case,
  i.e., it considers and implements the execution semantics of the complete UML
  Activity Diagram language.

  FunnyQT is a model querying and model transformation library for the
  functional Lisp-dialect Clojure providing a comprehensive and efficient
  querying and transformation API, many parts of which are provided as
  task-oriented embedded DSLs.
\end{abstract}


\section{Introduction}
\label{sec:introduction}

This paper describes the FunnyQT\footnote{\url{http://funnyqt.org}}
~\cite{Horn2013MQWFQ} solution of the TTC 2015 Model Execution
Case~\cite{model-execution-case-desc}.  It implements the third variant of the
case description, i.e., it implements the execution semantics of the complete
UML Activity Diagram language.  The solution project is available on
Github\footnote{\url{https://github.com/tsdh/ttc15-model-execution-funnyqt}},
and it is set up for easy reproduction on a SHARE image\footnote{\url{FIXME:
    add SHARE URL}}.

FunnyQT is a model querying and transformation library for the functional Lisp
dialect Clojure\footnote{\url{http://clojure.org}}.  Queries and
transformations are plain Clojure programs using the features provided by the
FunnyQT API.

As a Lisp, Clojure provides strong metaprogramming capabilities that are
exploited by FunnyQT in order to define several \emph{embedded domain-specific
  languages} (DSL, \cite{book:Fowler2010DSL}) for different querying and
transformation tasks.

FunnyQT is designed with extensibility in mind.  By default, it supports EMF
\cite{Steinberg2008EEM} models and
JGraLab\footnote{\url{http://jgralab.github.io}} TGraph models.  Support for
other modeling frameworks can be added without having to touch FunnyQT's
internals.

The FunnyQT API is structured into the following namespaces, each namespace
providing constructs supporting concrete querying and transformation use-cases:

\begin{compactdesc}
\item[funnyqt.emf] EMF-specific model management API
\item[funnyqt.tg] JGraLab/TGraph-specific model management API
\item[funnyqt.generic] Protocol-based, generic model management API
\item[funnyqt.query] Generic querying constructs such as quantified expressions
  or regular path expressions
\item[funnyqt.polyfns] Constructs for defining polymorphic functions
  dispatching on metamodel types
\item[funnyqt.pmatch] Pattern matching constructs
\item[funnyqt.relational] Constructs for logic-based, relational model querying
  inspired by Prolog
\item[funnyqt.in-place] In-place transformation rule definition constructs
\item[funnyqt.model2model] Out-place transformation definition constructs
  similar to ATL or QVT Operational Mappings
\item[funnyqt.extensional] Transformation API similar to GReTL
\item[funnyqt.bidi] Constructs for defining bidirectional transformations
  similar to QVT Relations
\item[funnyqt.coevo] Constructs for transformations that evolve a metamodel and
  a conforming model simultaneously at runtime
\item[funnyqt.visualization] Model visualization
\item[funnyqt.xmltg] Constructs for querying and modifying XML files as models
  conforming to a DOM-like metamodel
\end{compactdesc}

For solving the model execution case, the \emph{funnyqt.emf},
\emph{funnyqt.query}, and \emph{funnyqt.polyfns} namespaces have been used.


\section{Solution Description}
\label{sec:solution-description}

The explanations in the case description about the operational semantics on UML
Activity Diagrams suggest an algorithmic solution to the transformation case.
The FunnyQT solution tries to be almost a literal translation of the case
description to Clojure code.

The first line of the solution calls the \code|generate-ecore-model-functions|
FunnyQT macro.

\begin{clojurecode}
(generate-ecore-model-functions "activitydiagram.ecore" ttc15-model-execution-funnyqt.ad a)
\end{clojurecode}

As its name suggests, it generates a metamodel-specific API.  This API is
generated into the namespace \code|ttc15-model-execution-funnyqt.ad|, and the
namespace alias \code|a| is used to refer to that namespace from the current
one.

The generated API consists of element creation functions, lazy element sequence
functions, attribute access functions, and reference access functions.  For
example, \code|(a/create-ControlToken! ad)| creates a new control token and
adds it to the activity diagram model \code|ad|, \code|(a/eall-Inputs ad)|
returns the lazy sequence of input elements in \code|ad|, \code|(a/running? n)|
and \code|(a/set-running! n true)| query and set the node \code|n|'s
\textsf{running} attribute, and \code|(a/->locals a)|, \code|(a/->set-locals! a
ls)|, and \code|(a/->add-locals! a l)| query, set, and add to the
\textsf{locals} reference of the activity \code|a|.

Metamodel-specific APIs created by the \code|generate-ecore-model-functions|
macro are independent of the underlying implementation kind.  The FunnyQT
solution uses a dynamic instance model but it would work equivalently if it was
run with an EMF model using classes generated for the metamodel's generator
model.

Instead of using the generated API, the solution could also use the generic EMF
API in which case the lazy sequence of a activity diagram models inputs would
be retrieved using \code|(eallcontents ad 'Input)|.  But the generated API is
slightly more concise and readable.

\bigskip{}

In the following, the solution is presented in a top-down manner similar to how
the case description defines the operational semantics of activity diagrams.
Listing~\vref{lst:main-loop} shows the function \code|execute-activity-diagram|
which contains the transformation's main loop.

\begin{listing}[h!tb]
\begin{clojurecode}
(defn execute-activity-diagram [ad]
  (let [activity (the (a/eall-Activities ad))
        trace (a/create-Trace! nil)]
    (a/->set-trace! activity trace)
    (init-variables activity (first (a/eall-Inputs ad)))
    (mapc #(a/set-running! % true) (a/->nodes activity))
    (loop [ens (filter a/isa-InitialNode? (a/->nodes activity))]
      (when (seq ens)
        (doseq+ [node ens]
          (exec-node node)
          (a/->add-executedNodes! trace node))
        (recur (enabled-nodes activity))))
    trace))
\end{clojurecode}
\caption{The main loop of executing activity diagrams}
\label{lst:main-loop}
\end{listing}

The function queries the single activity in the diagram, creates a new trace,
and assigns that to the activity.  Then, the activity's variables are
initialized and its nodes are set running.

Then, a \code|loop|-\code|recur| iteration\footnote{\code|loop| is not a loop
  in the sense of Java's \code|for| or \code|while| but a local tail-recursion
  construct.  The \code|loop| declares variables with their initial bindings,
  and in the \code|loop|'s body \code|recur| forms may recurse back to the
  beginning of the \code|loop| providing new bindings for the \code|loop|'s
  variables.} performs the actual execution of the activity.  The variable
\code|ens| is bound to the enabled nodes.  Initially, those are the activity's
initial nodes from which there can only be one.  As long as there are enabled
nodes left, each node gets executed one after the other and then added to the
trace.  Thereafter, the loop is restarted with the nodes that are enabled at
that point in time.  Eventually, there won't be any enabled nodes left, and
then the function returns the trace.

So the first step in the execution of an activity is the initialization of its
local and input variables.  The corresponding function \code|init-variables| is
shown in listing \vref{lst:init-variables}.  For locals, their current value is
set to their initial value if there is one defined.  For input variables, their
current value is set to the value of the input's corresponding input value
element.

\begin{listing}[h!tb]
\begin{clojurecode}
(defn init-variables [activity input]
  (doseq+ [lv (a/->locals activity)]
    (when-let [init-value (a/->initialValue lv)]
      (a/->set-currentValue! lv init-value)))
  (doseq+ [iv (and input (a/->inputValues input))]
    (when-let [val (a/->value iv)]
      (a/->set-currentValue! (a/->variable iv) val))))
\end{clojurecode}
\caption{Initialization of variables}
\label{lst:init-variables}
\end{listing}

After initializing the variables, the main function sets the activity's nodes
running, and the main loop starts with the activity's initial node which will
be executed.

For different kinds of activity nodes, different execution semantics have to be
encoded.  This is exactly the use-case of FunnyQT's polymorphic functions
(polyfn).  A polymorphic function is declared once, and then different
implementations for instances of different metamodel types can be defined.
When the polyfn is called, a polymorphic dispatch based on the polyfn's first
argument's metamodel type is performed to pick out the right
implementation\footnote{Polyfns support multiple inheritance.  In case of an
  ambiguity during dispatch, e.g., two or more inherited implementations are
  applicable, an error is signaled.}.

Listing \vref{lst:exec-node-initial-node} shows the declaration of the polyfn
\code|exec-node| and its implementation for initial nodes.  The declaration
only defines the name of the polyfn and the number of its arguments (just one,
here).  The implementation for initial nodes simply offers one new control
token to the initial node's outgoing control flow edge.\footnote{The FunnyQT
  function \code|the| is similar to Clojure's \code|first| except that it
  signals an error if the given collection contains zero or more than one
  element.  Thus, it makes the assumption that there must be only one outgoing
  control flow explicit.}

\begin{listing}[h!tb]
\begin{clojurecode}
(declare-polyfn exec-node [node])

(defn offer-one-ctrl-token [node]
  (let [ctrl-t (a/create-ControlToken! nil)
        out-cf (the (a/->outgoing node))
        offer  (a/create-Offer! nil {:offeredTokens [ctrl-t]})]
    (a/->add-heldTokens! node ctrl-t)
    (a/->add-offers! out-cf offer)))

(defpolyfn exec-node InitialNode [i]
  (offer-one-ctrl-token i))
\end{clojurecode}
\caption{Declaration of polyfn \code|exec-node| and its implementation for initial nodes}
\label{lst:exec-node-initial-node}
\end{listing}

Listing \vref{lst:exec-node-join-merge-decision-node} shows the
\code|exec-node| implementations for join, merge, and decision nodes.  Join and
Merge nodes simply consume their input offers and pass the tokens they have
been offered on all outgoing control flows.  Decision nodes act similar but
offer their input tokens only on the outgoing control flow whose guard
variable's current value is true\footnote{\code|(the predicate collection)|
  returns the single element of the collection for which the predicate returns
  true.  If there is no or more elements satisfying the predicate, an error is
  signaled.}.

\begin{listing}[h!tb]
\begin{clojurecode}
(defn pass-tokens
  ([n] (pass-tokens n nil))
  ([n out-cf]
   (let [in-toks (consume-offers n)]
     (a/->set-heldTokens! n in-toks)
     (doseq+ [out-cf (if out-cf [out-cf] (a/->outgoing n))]
       (a/->add-offers!
        out-cf (a/create-Offer!
                nil {:offeredTokens in-toks}))))))

(defpolyfn exec-node JoinNode [jn]
  (pass-tokens jn))

(defpolyfn exec-node MergeNode [mn]
  (pass-tokens mn))

(defpolyfn exec-node DecisionNode [dn]
  (pass-tokens dn (the #(-> % a/->guard a/->currentValue a/value)
                       (a/->outgoing dn))))
\end{clojurecode}
\caption{\code|exec-node| impls for join, merge, and decision nodes}
\label{lst:exec-node-join-merge-decision-node}
\end{listing}

So how does a node consume offers?  This is defined by the
\code|consume-offers| function shown in listing \vref{lst:consume-offers}.

\begin{listing}[h!tb]
\begin{clojurecode}
(defn consume-offers [node]
  (let [offers (mapcat a/->offers (a/->incoming node))
        tokens (mapcat a/->offeredTokens offers)
        [ctrl-toks fork-toks] ((juxt filter remove) a/isa-ControlToken? tokens)]
    (mapc edelete! offers)
    (doseq+ [c ctrl-toks] (a/->set-holder! c nil))
    (doseq+ [ft fork-toks]
      (a/->set-holder! (a/->baseToken ft) nil)
      (a/set-remainingOffersCount! ft (dec (a/remainingOffersCount ft)))
      (when (zero? (a/remainingOffersCount ft))
        (edelete! ft)))
    (concat ctrl-toks (remove #(zero? (a/remainingOffersCount %)) fork-toks))))
\end{clojurecode}
\caption{Consuming offers}
\label{lst:consume-offers}
\end{listing}



\section{Evaluation}
\label{sec:evaluation}



\section{Conclusion}
\label{sec:conclusion}



\bibliographystyle{eptcs}
\bibliography{ttc-model-execution}
\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-command-extra-options: "-shell-escape"
%%% End:

%  LocalWords:  parallelizes
