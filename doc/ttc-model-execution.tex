\documentclass[submission]{eptcs}
\providecommand{\event}{TTC 2015}

\usepackage[T1]{fontenc}
\usepackage{varioref}
\usepackage{hyperref}

\usepackage{url}
\usepackage{paralist}
\usepackage{graphicx}
\usepackage[cache]{minted}
\newminted{clojure}{fontsize=\fontsize{9}{9},linenos,numbersep=3pt,numberblanklines=false,firstnumber=last}
\newmintinline{clojure}{fontsize=\small}
\newcommand{\code}{\clojureinline}
\VerbatimFootnotes

\title{Solving the TTC Model Execution Case with FunnyQT}
\author{Tassilo Horn
  \institute{Institute for Software Technology, University Koblenz-Landau, Germany}
  \email{horn@uni-koblenz.de}}

\def\titlerunning{Solving the TTC Model Execution Case with FunnyQT}
\def\authorrunning{T. Horn}

\begin{document}
\maketitle

\begin{abstract}
  This paper describes the FunnyQT solution to the TTC 2015 Model Execution
  transformation case.  The solution solves the third variant of the case,
  i.e., it considers and implements the execution semantics of the complete UML
  Activity Diagram language.

  FunnyQT is a model querying and model transformation library for the
  functional Lisp-dialect Clojure providing a comprehensive and efficient
  querying and transformation API, many parts of which are provided as
  task-oriented embedded DSLs.
\end{abstract}


\section{Introduction}
\label{sec:introduction}

This paper describes the FunnyQT\footnote{\url{http://funnyqt.org}}
~\cite{Horn2013MQWFQ,funnyqt-icgt15} solution of the TTC 2015 Model Execution
Case~\cite{model-execution-case-desc}.  It implements the third variant of the
case description, i.e., it implements the execution semantics of the complete
UML Activity Diagram language.  The solution project is available on
Github\footnote{\url{https://github.com/tsdh/ttc15-model-execution-funnyqt}},
and it is set up for easy reproduction on a SHARE image\footnote{The SHARE
  image name is \verb|ArchLinux64_TTC15-FunnyQT|}.

FunnyQT is a model querying and transformation library for the functional Lisp
dialect Clojure\footnote{\url{http://clojure.org}}.  Queries and
transformations are plain Clojure programs using the features provided by the
FunnyQT API.

As a Lisp, Clojure provides strong metaprogramming capabilities that are
exploited by FunnyQT in order to define several \emph{embedded domain-specific
  languages} (DSL, \cite{book:Fowler2010DSL}) for different querying and
transformation tasks.

FunnyQT is designed with extensibility in mind.  By default, it supports EMF
\cite{Steinberg2008EEM} models and
JGraLab\footnote{\url{http://jgralab.github.io}} TGraph models.  Support for
other modeling frameworks can be added without having to touch FunnyQT's
internals.

The FunnyQT API is structured into the following namespaces, each namespace
providing constructs supporting concrete querying and transformation use-cases:

\begin{compactdesc}
\item[funnyqt.emf] EMF-specific model management API
\item[funnyqt.tg] JGraLab/TGraph-specific model management API
\item[funnyqt.generic] Protocol-based, generic model management API
\item[funnyqt.query] Generic querying constructs such as quantified expressions
  or regular path expressions
\item[funnyqt.polyfns] Constructs for defining polymorphic functions
  dispatching on metamodel types
\item[funnyqt.pmatch] Pattern matching constructs
\item[funnyqt.relational] Constructs for logic-based, relational model querying
  inspired by Prolog
\item[funnyqt.in-place] In-place transformation rule definition constructs
\item[funnyqt.model2model] Out-place transformation definition constructs
  similar to ATL or QVT Operational Mappings
\item[funnyqt.extensional] Transformation API similar to GReTL
\item[funnyqt.bidi] Constructs for defining bidirectional transformations
  similar to QVT Relations
\item[funnyqt.coevo] Constructs for transformations that evolve a metamodel and
  a conforming model simultaneously at runtime
\item[funnyqt.visualization] Model visualization
\item[funnyqt.xmltg] Constructs for querying and modifying XML files as models
  conforming to a DOM-like metamodel
\end{compactdesc}

For solving the model execution case, the \emph{funnyqt.emf},
\emph{funnyqt.query}, and \emph{funnyqt.polyfns} namespaces have been used.


\section{Solution Description}
\label{sec:solution-description}

The explanations in the case description about the operational semantics on UML
Activity Diagrams suggest an algorithmic solution to the transformation case.
The FunnyQT solution tries to be almost a literal translation of the case
description to Clojure code.

The first line of the solution calls the \code|generate-ecore-model-functions|
FunnyQT macro.

\begin{clojurecode}
(generate-ecore-model-functions "activitydiagram.ecore" ttc15-model-execution-funnyqt.ad a)
\end{clojurecode}

As its name suggests, it generates a metamodel-specific API.  This API is
generated into the namespace \code|ttc15-model-execution-funnyqt.ad|, and the
namespace alias \code|a| is used to refer to that namespace from the current
one.

The generated API consists of element creation functions, lazy element sequence
functions, attribute access functions, and reference access functions.  For
example, \code|(a/create-ControlToken! ad)| creates a new control token and
adds it to the activity diagram model \code|ad|, \code|(a/all-Inputs ad)|
returns the lazy sequence of input elements in \code|ad|, \code|(a/running? n)|
and \code|(a/set-running! n true)| query and set the node \code|n|'s
\textsf{running} attribute, and \code|(a/->locals a)|, \code|(a/->set-locals! a
ls)|, and \code|(a/->add-locals! a l)| query, set, and add to the
\textsf{locals} reference of the activity \code|a|.

Metamodel-specific APIs created by the \code|generate-ecore-model-functions|
macro are independent of the underlying implementation kind.  The FunnyQT
solution uses a dynamic instance model but it would work equivalently if it was
run with an EMF model using classes generated for the metamodel's generator
model.

Instead of using the generated API, the solution could also use the generic EMF
API in which case the lazy sequence of a activity diagram models inputs would
be retrieved using \code|(eallcontents ad 'Input)|.  But the generated API is
slightly more concise and readable.

\bigskip{}

In the following, the solution is presented in a top-down manner similar to how
the case description defines the operational semantics of activity diagrams.
Listing~\vref{lst:execute-activity-diagram} shows the function
\code|execute-activity-diagram| which contains the transformation's main loop.

\begin{listing}[h!tb]
\begin{clojurecode}
(defn execute-activity-diagram [ad]
  (let [activity (the (a/all-Activities ad))
        trace (a/create-Trace! nil)]
    (a/->set-trace! activity trace)
    (init-variables activity (first (a/all-Inputs ad)))
    (mapc #(a/set-running! % true) (a/->nodes activity))
    (loop [ens (filter a/isa-InitialNode? (a/->nodes activity))]
      (when (seq ens)
        (doseq+ [node ens]
          (exec-node node)
          (a/->add-executedNodes! trace node))
        (recur (enabled-nodes activity))))
    trace))
\end{clojurecode}
\caption{The main loop of executing activity diagrams}
\label{lst:execute-activity-diagram}
\end{listing}

The function queries the single activity in the diagram, creates a new trace,
and assigns that to the activity.  Then, the activity's variables are
initialized and its nodes are set running.

Then, a \code|loop|-\code|recur| iteration\footnote{\code|loop| is not a loop
  in the sense of Java's \code|for| or \code|while| but a local tail-recursion
  construct.  The \code|loop| declares variables with their initial bindings,
  and in the \code|loop|'s body \code|recur| forms may recurse back to the
  beginning of the \code|loop| providing new bindings for the \code|loop|'s
  variables.} performs the actual execution of the activity.  The variable
\code|ens| is bound to the enabled nodes.  Initially, those are the activity's
initial nodes from which there can only be one.  As long as there are enabled
nodes left, each node gets executed one after the other and then added to the
trace.  Thereafter, the loop is restarted with the nodes that are enabled at
that point in time.  Eventually, there won't be any enabled nodes left, and
then the function returns the trace.

So the first step in the execution of an activity is the initialization of its
local and input variables.  The corresponding function \code|init-variables| is
shown in listing \vref{lst:init-variables}.  For locals, their current value is
set to their initial value if there is one defined.  For input variables, their
current value is set to the value of the input's corresponding input value
element.

\begin{listing}[h!tb]
\begin{clojurecode}
(defn init-variables [activity input]
  (doseq+ [lv (a/->locals activity)]
    (when-let [init-value (a/->initialValue lv)]
      (a/->set-currentValue! lv init-value)))
  (doseq+ [iv (and input (a/->inputValues input))]
    (when-let [val (a/->value iv)]
      (a/->set-currentValue! (a/->variable iv) val))))
\end{clojurecode}
\caption{Initialization of variables}
\label{lst:init-variables}
\end{listing}

After initializing the variables, the main function sets the activity's nodes
running, and the main loop starts with the activity's initial node which will
be executed.

For different kinds of activity nodes, different execution semantics have to be
encoded.  This is exactly the use-case of FunnyQT's polymorphic functions
(polyfn).  A polymorphic function is declared once, and then different
implementations for instances of different metamodel types can be defined.
When the polyfn is called, a polymorphic dispatch based on the polyfn's first
argument's metamodel type is performed to pick out the right
implementation\footnote{Polyfns support multiple inheritance.  In case of an
  ambiguity during dispatch, e.g., two or more inherited implementations are
  applicable, an error is signaled.}.

Listing \vref{lst:exec-node-initial-node} shows the declaration of the polyfn
\code|exec-node| and its implementation for initial nodes.  The declaration
only defines the name of the polyfn and the number of its arguments (just one,
here).  The implementation for initial nodes simply offers one new control
token to the initial node's outgoing control flow edge.\footnote{The FunnyQT
  function \code|the| is similar to Clojure's \code|first| except that it
  signals an error if the given collection contains zero or more than one
  element.  Thus, it makes the assumption that there must be only one outgoing
  control flow explicit.}

\begin{listing}[h!tb]
\begin{clojurecode}
(declare-polyfn exec-node [node])

(defn offer-one-ctrl-token [node]
  (let [ctrl-t (a/create-ControlToken! nil)
        out-cf (the (a/->outgoing node))
        offer  (a/create-Offer! nil {:offeredTokens [ctrl-t]})]
    (a/->add-heldTokens! node ctrl-t)
    (a/->add-offers! out-cf offer)))

(defpolyfn exec-node InitialNode [i]
  (offer-one-ctrl-token i))
\end{clojurecode}
\caption{Declaration of polyfn \code|exec-node| and its implementation for initial nodes}
\label{lst:exec-node-initial-node}
\end{listing}

Listing \vref{lst:exec-node-join-merge-decision-node} shows the
\code|exec-node| implementations for join, merge, and decision nodes.  Join and
Merge nodes simply consume their input offers and pass the tokens they have
been offered on all outgoing control flows.  Decision nodes act similar but
offer their input tokens only on the outgoing control flow whose guard
variable's current value is true\footnote{\code|(the predicate collection)|
  returns the single element of the collection for which the predicate returns
  true.  If there is no or more elements satisfying the predicate, an error is
  signaled.}.

\begin{listing}[h!tb]
\begin{clojurecode}
(defn pass-tokens
  ([n] (pass-tokens n nil))
  ([n out-cf]
   (let [in-toks (consume-offers n)]
     (a/->set-heldTokens! n in-toks)
     (doseq+ [out-cf (if out-cf [out-cf] (a/->outgoing n))]
       (a/->add-offers!
        out-cf (a/create-Offer!
                nil {:offeredTokens in-toks}))))))

(defpolyfn exec-node JoinNode [jn]
  (pass-tokens jn))

(defpolyfn exec-node MergeNode [mn]
  (pass-tokens mn))

(defpolyfn exec-node DecisionNode [dn]
  (pass-tokens dn (the #(-> % a/->guard a/->currentValue a/value)
                       (a/->outgoing dn))))
\end{clojurecode}
\caption{\code|exec-node| impls for join, merge, and decision nodes}
\label{lst:exec-node-join-merge-decision-node}
\end{listing}

So how does a node consume offers?  This is defined by the
\code|consume-offers| function shown in listing \vref{lst:consume-offers}.
First, the offers and the tokens offered by them are calculated.  Then, the
offered tokens are divided into control and forked tokens.  For control tokens,
their holder is unset.  For forked tokens, the corresponding base token's
holder is unset.  The forked tokens' \textsf{remainingOffersCount} is
decremented.  If it has become zero then, the forked token is removed from its
holder.  Lastly, the offers are deleted, and the incoming tokens are returned.

\begin{listing}[h!tb]
\begin{clojurecode}
(defn consume-offers [node]
  (let [offers    (mapcat a/->offers (a/->incoming node))
        tokens    (mapcat a/->offeredTokens offers)
        ctrl-toks (filter a/isa-ControlToken? tokens)
        fork-toks (filter a/isa-ForkedToken? tokens)]
    (doseq+ [ct ctrl-toks]
      (a/->set-holder! ct nil))
    (doseq+ [ft fork-toks]
      (when-let [bt (a/->baseToken ft)]
        (a/->set-holder! bt nil))
      (a/set-remainingOffersCount! ft (dec (a/remainingOffersCount ft)))
      (when (zero? (a/remainingOffersCount ft))
        (a/->set-holder! ft nil)))
    (mapc edelete! offers)
    tokens))
\end{clojurecode}
\caption{Consuming offers}
\label{lst:consume-offers}
\end{listing}

The remaining kinds of activity nodes are fork nodes, activity final nodes and
opaque actions.  Their \code|exec-node| implementations are printed in listing
\vref{lst:exec-node-final-opaque}.

A fork node consumes its offers and creates one forked token per incoming
token.  The incoming tokens are set as the forked tokens' base tokens, and the
remaining offers count is set to the number of outgoing control flows.  All
created forked tokens are offered on each outgoing control flow.

\begin{listing}[h!tb]
\begin{clojurecode}
(defpolyfn exec-node ForkNode [fn]
  (let [in-toks  (consume-offers fn)
        out-cfs  (a/->outgoing fn)
        out-toks (mapv #(a/create-ForkedToken!
                         nil {:baseToken %, :holder fn,
                              :remainingOffersCount (count out-cfs)})
                       in-toks)]
    (a/->set-heldTokens! fn in-toks)
    (doseq+ [out-cf out-cfs]
      (a/->add-offers! out-cf (a/create-Offer!
                               nil {:offeredTokens out-toks})))))
(defpolyfn exec-node ActivityFinalNode [afn]
  (consume-offers afn)
  (mapc #(a/set-running! % false)
        (-> afn a/->activity a/->nodes)))

(defpolyfn exec-node OpaqueAction [oa]
  (consume-offers oa)
  (mapc eval-exp (a/->expressions oa))
  (offer-one-ctrl-token oa))
\end{clojurecode}
\caption{\code|exec-node| impls for activity final nodes and opaque actions}
\label{lst:exec-node-final-opaque}
\end{listing}

An activity final node simply consumes all offers and then sets the
\textsf{running} attribute of all nodes contained by the executed activity to
false.  An opaque action also consumes all offers, then evaluates all its
expressions in sequence using the \code|eval-exp| function, and finally offers
one single control token on the outgoing control flow.

How an expression is evaluated depends on (1) the type of the expression, and
(2) on the value of the \textsf{operator} attribute.  The expression's type is
only important in order to separate unary from binary expressions, and the
operator defines the semantics.  Therefore, the \code|eval-exp| function shown
in listing \vref{lst:eval-exp} has a special case for boolean unary expressions
which negates the expression's current value using \code|not|.  For all binary
expressions, the map \code|op2fn| mapping from operator enum constants to
Clojure functions having the semantics of that operator is used.  The function
determined by looking up the expression's operator is applied to both operands
to compute the new value.

\begin{listing}[h!tb]
\begin{clojurecode}
(def op2fn {(a/enum-IntegerCalculationOperator-ADD)           +
            (a/enum-IntegerCalculationOperator-SUBRACT)       -
            (a/enum-IntegerComparisonOperator-SMALLER)        <
            (a/enum-IntegerComparisonOperator-SMALLER_EQUALS) <=
            (a/enum-IntegerComparisonOperator-EQUALS)         =
            (a/enum-IntegerComparisonOperator-GREATER_EQUALS) >=
            (a/enum-IntegerComparisonOperator-GREATER)        >
            (a/enum-BooleanBinaryOperator-AND)                #(and %1 %2)
            (a/enum-BooleanBinaryOperator-OR)                 #(or  %1 %2)})

(defn eval-exp [exp]
  (a/set-value! (-> exp a/->assignee a/->currentValue)
                (if (a/isa-BooleanUnaryExpression? exp)
                  (not (-> exp a/->operand a/->currentValue a/value))
                  ((op2fn (a/operator exp))
                   (-> exp a/->operand1 a/->currentValue a/value)
                   (-> exp a/->operand2 a/->currentValue a/value)))))
\end{clojurecode}
\caption{Evaluation of expressions}
\label{lst:eval-exp}
\end{listing}

After executing all enabled nodes, the transformation's main function
\code|execute-activity-diagram| from listing
\vref{lst:execute-activity-diagram} recomputes the enabled nodes and resumes
the execution.  The enabled nodes are computed by the \code|enabled-nodes|
function shown in listing \vref{lst:enabled-nodes}.  The enabled nodes are
those nodes of a given activity which are set running, are no initial
nodes\footnote{Initial nodes have to be excluded because if they are set
  running, all of their (zero) incoming control flows have offers.}, and
receive an offer on each incoming control flow, or, in the case of a merge
node, on one incoming control flow.

\begin{listing}[h!tb]
\begin{clojurecode}
(defn enabled-nodes [activity]
  (filter (fn [n]
            (and (a/running? n)
                 (not (a/isa-InitialNode? n))
                 ((if (a/isa-MergeNode? n) exists? forall?)
                  #(seq (a/->offers %)) (a/->incoming n))))
          (a/->nodes activity)))
\end{clojurecode}
\caption{Computation of enabled nodes}
\label{lst:enabled-nodes}
\end{listing}

These 92 NCLOC of algorithmic FunnyQT/Clojure code implement the complete
operational semantics of UML Activity Diagrams (with the exception of data
flows which has not been demanded by the case description).

\section{Evaluation}
\label{sec:evaluation}

In this section, the FunnyQT solution is evaluated according to the criteria
stated in the case description.

\paragraph{Correctness.}

The JUnit test suite of the reference Java solution has been translated to
Clojure and its unit testing library.  The very same assertions are tested,
i.e., the execution order of nodes is tested and the final values of variables
are checked.  Additionally, it is checked that after an activity has been
executed, there are no tokens leftover whose existence would hint at some bug
in the implementation.

All tests pass for all provided test models, so the solution is correct at
least with respect to these models and the set of assertions tested by the unit
test.


\paragraph{Understandability and conciseness.}

With 103 lines of non-commented source code, the FunnyQT solution is quite
concise.

Of course, understandability is a very subjective measure measure.  The
solution should be evident for any Clojure programmer but even without prior
Clojure knowledge, the solution shouldn't be hard to follow due to the usage of
the metamodel-specific API.  Another strong point is that all steps in the
execution of an activity are encoded in one function each whose definition is
almost a literal translation of the English description to FunnyQT/Clojure
code.


\paragraph{Performance.}

Table \vref{tab:runtimes} shows the execution times of the FunnyQT solution for
all provided test models.  These times were measured on a normal 4-core laptop
with 2.6 GHz and 2 GB of RAM dedicated to the JVM.

\begin{table}[h!tb]
  \centering
  \begin{tabular}{|l | r |}
    \hline
    \textbf{Model} & \textbf{Execution time}\\
    \hline
    \emph{test1} & 1.4 ms\\
    \emph{test2} & 0.8 ms\\
    \emph{test3} & 3.1 ms\\
    \emph{test4} & 4.3 ms\\
    \emph{test5} & 0.7 ms\\
    \emph{test6 (false)} & 6.5 ms\\
    \emph{test6 (true)}  & 10.8 ms\\
    \emph{test-performance-variant-1} & 2093.3 ms\\
    \emph{test-performance-variant-2} & 248.5 ms\\
    \emph{test-performance-variant-3-1} & 118.2 ms\\
    \emph{test-performance-variant-3-2} & 172.8 ms\\
    \hline
  \end{tabular}
  \caption{Execution times for the provided test models}
  \label{tab:runtimes}
\end{table}

When compared with the reference Java solution, there are no notable
differences for the smaller models.  For the model
\emph{test-performance-variant-1}, the Java solution is slightly faster.
However, for the model \emph{test-performance-variant-2} the Java solution
takes about 1600 ms, and for the \emph{test-performance-variant-3-1} it takes
about 8000 ms.  So for these models, the FunnyQT solution is an order of
magnitudes faster than the Java solution which hints at some inefficiencies in
how parallel branches are executed in the latter.


\section{Conclusion}
\label{sec:conclusion}

In this paper, the FunnyQT solution to the TTC 2015 Model Execution case has
been discussed.  The solution implements the full operational semantics of UML
Activity Diagrams with the exception of object flows which haven't been
considered in this case.

The specification is very concise.  The complete implementation amounts to only
103 lines of code without counting comments, empty lines, and the solution
namespace's namespace declaration (similar to Java's \code|package| and
\code|import| statements).

The specification is also well-understandable.  The description of the
semantics given in the case description have been translated almost literally
to functions and one polymorphic function.  These functions use a
metamodel-specific API which FunnyQT has generated from the activity diagram
metamodel.

The FunnyQT solution also performs very well.  In general, its execution times
are very similar to those of the Java reference solution, and for two of the
performance test models, the FunnyQT solution is in fact several times faster.

Overall, FunnyQT seems to be very adequate for defining model interpreters.
Especially its polymorphic function facility has been explicitly designed for
these kinds of tasks.

\bibliographystyle{eptcs}
\bibliography{ttc-model-execution}
\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% TeX-command-extra-options: "-shell-escape"
%%% End:

%  LocalWords:  parallelizes
